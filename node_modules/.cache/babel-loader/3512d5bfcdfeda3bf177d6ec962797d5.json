{"ast":null,"code":"import * as React from 'react';\nimport { parse as parseQueryString, encodeQueryParams } from 'serialize-query-params';\nimport { useQueryParam } from './useQueryParam';\nimport updateUrlQuery from './updateUrlQuery';\nimport { QueryParamContext } from './QueryParamProvider'; // from https://usehooks.com/usePrevious/\n\nfunction usePrevious(value) {\n  var ref = React.useRef(value);\n  React.useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n} // from https://github.com/lodash/lodash/issues/2340#issuecomment-360325395\n\n\nfunction isShallowEqual(objA, objB) {\n  for (var key in objA) if (!(key in objB) || objA[key] !== objB[key]) return false;\n\n  for (var key in objB) if (!(key in objA) || objA[key] !== objB[key]) return false;\n\n  return true;\n}\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\n\n\nexport var useQueryParams = function (paramConfigMap) {\n  var _a = React.useContext(QueryParamContext),\n      history = _a.history,\n      location = _a.location;\n\n  var locationIsObject = typeof location === 'object'; // memoize paramConfigMap to make the API nicer for consumers.\n  // otherwise we'd have to useQueryParams(useMemo(() => { foo: NumberParam }, []))\n\n  var prevParamConfigMap = usePrevious(paramConfigMap);\n  var hasNewParamConfig = isShallowEqual(prevParamConfigMap, paramConfigMap); // prettier-ignore\n\n  var memoParamConfigMap = React.useMemo(function () {\n    return paramConfigMap;\n  }, [hasNewParamConfig]);\n  paramConfigMap = memoParamConfigMap; // ref with current version history object (see #46)\n\n  var refHistory = React.useRef(history);\n  React.useEffect(function () {\n    refHistory.current = history;\n  }, [history]); // ref with current version location object (see #46)\n\n  var refLocation = React.useRef(location);\n  React.useEffect(function () {\n    refLocation.current = location;\n  }, [location]);\n  var search = locationIsObject ? location.search : ''; // read in the raw query\n\n  var rawQuery = React.useMemo(function () {\n    return parseQueryString(search) || {};\n  }, [search]); // parse each parameter via useQueryParam\n  // we reuse the logic to not recreate objects\n\n  var paramNames = Object.keys(paramConfigMap);\n  var paramValues = paramNames.map(function (paramName) {\n    return useQueryParam(paramName, paramConfigMap[paramName], rawQuery)[0];\n  }); // we use a memo here to prevent recreating the containing decodedValues object\n  // which would break === comparisons even if no values changed.\n\n  var decodedValues = React.useMemo(function () {\n    // iterate over the decoded values and build an object\n    var decodedValues = {};\n\n    for (var i = 0; i < paramNames.length; ++i) {\n      decodedValues[paramNames[i]] = paramValues[i];\n    }\n\n    return decodedValues;\n  }, paramValues); // eslint-disable-line react-hooks/exhaustive-deps\n  // create a setter for updating multiple query params at once\n\n  var setQuery = React.useCallback(function (changes, updateType) {\n    // encode as strings for the URL\n    var encodedChanges = encodeQueryParams(paramConfigMap, changes); // update the URL\n\n    updateUrlQuery(encodedChanges, refHistory.current.location || refLocation.current, // see #46\n    refHistory.current, updateType);\n  }, [paramConfigMap]); // no longer Partial\n\n  return [decodedValues, setQuery];\n};\nexport default useQueryParams;","map":null,"metadata":{},"sourceType":"module"}